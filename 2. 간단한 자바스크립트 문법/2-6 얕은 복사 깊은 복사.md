## 2-6-1 얕은 복사 vs 깊은 복사

<br>

### 얕은 복사 vs 깊은 복사
- **얕은복사는 주소(참조)값이 복사되므로 객체/배열 내부를 변경하면 원본도 같이 변경**
    - `name`: 문자열(값 타입, Primitive) → 값 자체가 복사됨. (number / string)
    - `nums`: 배열(참조 타입, Reference) → 주소(참조)만 복사됨. (내부를 바꾸면 둘 다 영향)

```js
const original = { name: "Alex", nums: [1, 2, 3] };
```

<br>

#### 1. 얕은 복사 - spread 문법
```js
const shallow1 = { ...original };
```

```js
shallow1.name = "Bella";
shallow1.nums[0] = 99;

console.log("original :", original); // name: "Alex", nums: [99, 2, 3]
console.log("shallow1 :", shallow1); // name: "Bella", nums: [99, 2, 3]
console.log("------");
```

<br>

#### 2. 얕은 복사 - `Object.assign`

```js
const shallow2 = Object.assign({}, original);
```

```js
shallow2.nums[1] = 888;
console.log("original :", original); // nums: [99, 888, 3]
console.log("shallow2 :", shallow2); // nums: [99, 888, 3]
console.log("------");
```

<br>

- **`name`을 변경해도 original.name에는 영향 없음 (값 타입이기 때문)**
- **`nums` 배열의 내부를 변경하면, `original`과 `shallow1`/`shallow2` 모두 영향 (같은 배열을 공유)**


<br>

#### 3. 깊은 복사

```js
const deep = JSON.parse(JSON.stringify(original));
deep.name = "Chris";           // deep.name만 바뀜 (original 영향 X)
deep.nums[2] = 555;            // deep.nums[2]만 바뀜 (original 영향 X)

console.log("original :", original); // name: "Alex", nums: [99, 888, 3]
console.log("deep     :", deep);     // name: "Chris", nums: [99, 888, 555]
```

<br>
<hr>
<br>

## 2-6-2 얕은 복사로 인한 버그 예제

function runExample() {

    // 쇼핑몰에서 카트 데이터를 복사해서 '주문'에 쓸 때 상황 가정
    const cart = {
      user: "Alex",
      items: [
        { id: 1, name: "노트북", price: 1000 },
        { id: 2, name: "마우스", price: 50 }
      ]
    };

    // "cart"를 '주문'용으로 얕은 복사
    const order = { ...cart };

    // 주문 화면에서 첫 번째 상품의 가격을 할인
    order.items[0].price = 900;

    // 원래 cart의 첫 상품 가격도 바뀜 (실제론 할인되면 안 되는데)
    console.log("[cart] 원본 카트:", cart.items);
    console.log("[order] 주문용 복사본:", order.items);

    // 그러면은 모두 다 깊은복사를 사용하면은 이런 일 생길일이 없지 않을까?
    // 메모리 낭비

}