## 2-6-1 얕은 복사 vs 깊은 복사

<br>

### 얕은 복사 vs 깊은 복사
- **얕은복사는 주소(참조)값이 복사되므로 객체/배열 내부를 변경하면 원본도 같이 변경**
    - `name`: 문자열(값 타입, Primitive) → 값 자체가 복사됨. (number / string)
    - `nums`: 배열(참조 타입, Reference) → 주소(참조)만 복사됨. (내부를 바꾸면 둘 다 영향)

```js
const original = { name: "Alex", nums: [1, 2, 3] };
```

<br>

#### 1. 얕은 복사 - spread 문법
```js
const shallow1 = { ...original };
```

```js
shallow1.name = "Bella";
shallow1.nums[0] = 99;

console.log("original :", original); // name: "Alex", nums: [99, 2, 3]
console.log("shallow1 :", shallow1); // name: "Bella", nums: [99, 2, 3]
console.log("------");
```

<br>

#### 2. 얕은 복사 - `Object.assign`

```js
const shallow2 = Object.assign({}, original);
```

```js
shallow2.nums[1] = 888;
console.log("original :", original); // nums: [99, 888, 3]
console.log("shallow2 :", shallow2); // nums: [99, 888, 3]
console.log("------");
```

<br>

- **`name`을 변경해도 original.name에는 영향 없음 (값 타입이기 때문)**
- **`nums` 배열의 내부를 변경하면, `original`과 `shallow1`/`shallow2` 모두 영향 (같은 배열을 공유)**


<br>

#### 3. 깊은 복사

```js
const deep = JSON.parse(JSON.stringify(original));
deep.name = "Chris";           // deep.name만 바뀜 (original 영향 X)
deep.nums[2] = 555;            // deep.nums[2]만 바뀜 (original 영향 X)

console.log("original :", original); // name: "Alex", nums: [99, 888, 3]
console.log("deep     :", deep);     // name: "Chris", nums: [99, 888, 555]
```

<br>
<hr>
<br>

## 2-6-2 얕은 복사로 인한 버그 예제

- 쇼핑몰에서 카트 데이터를 복사해서 '주문'에 쓸 때 상황 가정

```js
const cart = {
  user: "Alex",
  items: [
    { id: 1, name: "노트북", price: 1000 },
    { id: 2, name: "마우스", price: 50 }
  ]
};
```

- `"cart"`를 '주문'용으로 얕은 복사

```js
const order = { ...cart };
```

- 주문 화면에서 첫 번째 상품의 가격을 할인

```js
order.items[0].price = 900;
```

- 원래 `cart`의 첫 상품 가격도 바뀜 (실제론 할인되면 안 됨) $\rightarrow$ 그러면은 모두 다 깊은복사를 사용하면은 이런 일 생길일이 없지 않을까? $\rightarrow$ 메모리 낭비?
  - **성능 & 메모리 오버헤드**
    - 깊은 복사는 객체 내부의 모든 중첩된 데이터까지 새로 복제
    - 즉, 데이터가 클수록 메모리와 CPU 자원을 많이 사용

  - **필요한 독립 복제는 낭비**
    - 예를 들어, 주문 시점에는 상품 목록(`items`) 은 동일하고,
      
      수량, 할인 정보, 사용자 입력 필드만 다를 수도 있음 → 이럴 때는 필요한 부분만 선택적으로 깊은 복사하는 게 더 효율적

<br>

- **1단계만 얕은 복사하고, 깊은 복사가 필요한 부분만 따로 처리**

```js
const order = { ...cart, items: cart.items.map(item => ({ ...item })) };
order.items[0].price = 900;

console.log(cart.items[0].price); 
```